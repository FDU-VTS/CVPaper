# Efficient Graph-Based Image Segmentation

∈

## 基础知识
 - 一张图是由不同的像素点构成的，本文的计算和构建都是基于像素点的运算，即`(RGB)`值
 - 最小生成树`(Minimum Spanning Tree | MST)`指的是，在图中建立一个连通图并且没有回路是生成树，而最小生成树指的是构成结果权值最小
 - 不同像素点之间的差:即`RGB`值之间的欧氏距离


## 最早的分割方法
&emsp;&emsp;使用给定的阈值或局部量来计算。
Zahn提出了一种*基于图的最小生成树（MST）*的分割方法，用来进行点聚类以及图像分割，前者权值是点间距离，后者权值是像素差异。

&emsp;&emsp;不足：根据阈值不同，会导致高可变性（大约是色彩对比强的一个区域）区域划分为多个区域；将ramp和constant region合并到一起。
Urquhart提出用边相连的点中边权值最小的进行归一化，找周围相似的。（不太明白？）

&emsp;&emsp;**另一种早期分割方法**：根据各个区域是否符合某种均匀性标准来分割，找均匀强度或梯度的区域，不适用于某个变化很大的区域。

&emsp;&emsp;**分割方法总结**：1.分成小块；2.与周围区域合并。

&emsp;&emsp;使用特征空间聚类：通过平滑数据——给定半径的超球面对各个点扩张其连通分量，找到簇，来保持该区域的边界，并对数据进行转换。（不太明白？）

&emsp;&emsp;**规范化切割标准。**
## 基于图的分割
&emsp;&emsp;区域内两个点间权值小，区间两点的权值大。
定义谓词D，用于计算两个区域边界上点的差异，C是区域内最小生成树中的最大权值,区域内差异计算：

 *Int(C)* = max *w(e)* , *e∈MST(C，E)*

&emsp;&emsp;区间差异定义为：

*Dif(C1,C2)* = min *w(vi,vj)* , *vi∈C1,vj∈C2,(vi,vj)∈E*

&emsp;&emsp;比较两个区域里的最小边权，也可将定义改为中值或分位数。

&emsp;&emsp;设定阈值：

 $$ D(C1,C2)=\left\{
\begin{aligned}
true, &  & \ if Dif(C1,C2)>M*Int(C1,C2)* \\
false, &  & \ otherwis
\end{aligned}
\right.
$$
其中，
*MInt(C1,C2)* =  *(Int(C1)+τ(C1),Int(C2)+τ(C2))*.

&emsp;&emsp;此处的τ是一个阈值函数，用来控制两个区域的区域间间距要在多大程度上大于他们的区域内间距才能被认定为两个区域间有明显的分割界限。举个例子来说，当其中一个区域很小时,Int（C)并不能很好的反应其区域内间距（极端的情况是当C只含一个节点时，Int（C）=0）。

&emsp;&emsp;本文在此处对τ的定义为|C|的负相关函数：τ(C) = k/|C|，其中k是一个常数。k要根据实验的具体情况来确定其值，但当k越大时，我们界定的可以区分两个区域的界限就越明显。

&emsp;&emsp;**分割算法**：（与克鲁斯卡尔算法构建最小生成树有密切关系。）

&emsp;&emsp;输入是一个有n个节点和m条边的图G，输出是一系列区域。步骤如下：

&emsp;&emsp;0.将边按照权重值以非递减方式排序

&emsp;&emsp;1.最初的分割记为S（0），即每一个节点属于一个区域。

&emsp;&emsp;2.按照以下的方式由S(q-1)构造S(q)：记第q条边连接的两个节点为vi和vj，如果在S(q-1)中vi和vj是分别属于两个区域并且第q条边的权重小于两个区域的区域内间距，则合并两个区域。否则令S(q) = S(q-1)。

&emsp;&emsp;3.从q=1到q=m，重复步骤2。

&emsp;&emsp;4.返回S(m)即为所求分割区域集合。

———————————————————补充————————————————————————————————————————
**高斯滤波器**：

参考：http://www.cnblogs.com/wangguchangqing/p/6407717.html
https://www.cnblogs.com/herenzhiming/articles/5276106.html

&emsp;&emsp;高斯变换就是用高斯函数对图像进行卷积，高斯滤波器是一种线性滤波器，能够有效抑制噪声，并平滑图像。其实质是取滤波器窗口内像素的均值作为输出。

&emsp;&emsp;*高斯函数公式如下*：

$f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{ -\frac{(x-\mu)^2}{2\sigma^2}}$
其中，$\mu$是x的均值,$\sigma$是方差。

&emsp;&emsp;由一维函数，我们可以推导出二维函数的公式如下：

$f(x,y) = \frac{1}{2\pi \sigma^2} e^{-\frac{(x^2+y^2)}{2\sigma^2} }$

&emsp;&emsp;高斯函数在图像处理中的使用，实际上就是对每个像素点的周边像素取平均值，从而达到平滑的效果，在取值(周边半径)时，周围像素点的半径越大，则图像的模糊度就越强。在实际计算时，利用高斯模糊按正态曲线分配周边像素的权重，从而求中心点的加权平均值。

&emsp;&emsp;高斯模糊的具体计算方式如下：

1.将中心点周围的八个点带入到高斯函数中，从而得到权重矩阵A1；

2.为使归一化，将矩阵A1中的各个点除以所有点(9个点)的权重和，得到归一化后的权重矩阵A2;

3.图片原始的像素矩阵分别乘以A2中各自的权重值，将得到的所有点的值加起来求平均，便得到中心点的高斯模糊值。图像中其余点相同求法。

&emsp;&emsp;注：1.彩色图片，可对RGB三通道分别作高斯模糊。

2.$\sigma$代表数据的离散程度，$\sigma$越大，中心系数越小，图像越平滑；反之，反之。

**拉普拉斯变换**：是为解决傅立叶变换等幅振荡的缺点。

&emsp;&emsp;首先了解一下*傅立叶变换*：

&emsp;&emsp;傅立叶变换是一种物理上探究频谱的方法，三角公式是：

&emsp;&emsp;$f(t) = \sum_{n=1}^\infty A_ncos(nw_0t+\varphi_n)+B$&emsp;&emsp;
其中,$w_0$表示基波。

&emsp;&emsp;由欧拉公式：
 $$ \left\{
\begin{aligned}
e^{ix} =cosx+isinx, \\
e^{-ix} =cosx -isinx,
\end{aligned}
\right.
$$
&emsp;&emsp;将傅立叶三角形式公式中的正余弦函数用指数函数表示，改写为用复指数表示的公式，如下：

&emsp;&emsp;$f(t) = \sum_{-\infty}^\infty F(nw_0)e^{jw_0t}$

&emsp;&emsp;将上述公式改为积分形式，即得到复指数形式公式为：

&emsp;&emsp;$F(w) =\int_{-\infty}^\infty f(t)e^{-jwt}dt$

&emsp;&emsp;但由于傅立叶变换是等幅振荡的正弦波，故当f(t)不断趋向无穷时，此时函数将不再收敛，这时候便不再适合使用傅立叶变换。于是，我们引入一个衰减因子，对其作变换。对函数y=f(t)乘上一个$e^{\sigma t}$,其中，$\sigma$>0。


&emsp;&emsp;$F(w) =\int_{-\infty}^\infty f(t)e^{-\sigma t}e^{-jwt}dt$

&emsp;&emsp;对上式进行合并同类项，可得到$F(w) =\int_{-\infty}^\infty f(t)e^{-t(\sigma+jw)}dt$.

我们将指数中的$$\sigma+jw$最初的分割记为S，于是得到拉普拉斯公式：
$\Rightarrow$&emsp;&emsp;$F(w) =\int_{-\infty}^\infty f(t)e^{-st}dt$

&emsp;&emsp;由上式推导，很清楚的知道，当s=jw时，拉普拉斯函数就变成了傅立叶函数，也就相当于拉氏不再具有衰减功能。

&emsp;&emsp;又由上述公式可以很直观地看到当取值$\sigma_0$刚好收敛时，则$\sigma$>$\sigma_0$的区域全都收敛。
